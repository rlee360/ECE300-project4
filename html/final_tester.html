
<!DOCTYPE html
  PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head>
      <meta http-equiv="Content-Type" content="text/html; charset=utf-8">
   <!--
This HTML was auto-generated from MATLAB code.
To make changes, update the MATLAB code and republish this document.
      --><title>final_tester</title><meta name="generator" content="MATLAB 9.7"><link rel="schema.DC" href="http://purl.org/dc/elements/1.1/"><meta name="DC.date" content="2019-12-27"><meta name="DC.source" content="final_tester.m"><style type="text/css">
html,body,div,span,applet,object,iframe,h1,h2,h3,h4,h5,h6,p,blockquote,pre,a,abbr,acronym,address,big,cite,code,del,dfn,em,font,img,ins,kbd,q,s,samp,small,strike,strong,sub,sup,tt,var,b,u,i,center,dl,dt,dd,ol,ul,li,fieldset,form,label,legend,table,caption,tbody,tfoot,thead,tr,th,td{margin:0;padding:0;border:0;outline:0;font-size:100%;vertical-align:baseline;background:transparent}body{line-height:1}ol,ul{list-style:none}blockquote,q{quotes:none}blockquote:before,blockquote:after,q:before,q:after{content:'';content:none}:focus{outine:0}ins{text-decoration:none}del{text-decoration:line-through}table{border-collapse:collapse;border-spacing:0}

html { min-height:100%; margin-bottom:1px; }
html body { height:100%; margin:0px; font-family:Arial, Helvetica, sans-serif; font-size:10px; color:#000; line-height:140%; background:#fff none; overflow-y:scroll; }
html body td { vertical-align:top; text-align:left; }

h1 { padding:0px; margin:0px 0px 25px; font-family:Arial, Helvetica, sans-serif; font-size:1.5em; color:#d55000; line-height:100%; font-weight:normal; }
h2 { padding:0px; margin:0px 0px 8px; font-family:Arial, Helvetica, sans-serif; font-size:1.2em; color:#000; font-weight:bold; line-height:140%; border-bottom:1px solid #d6d4d4; display:block; }
h3 { padding:0px; margin:0px 0px 5px; font-family:Arial, Helvetica, sans-serif; font-size:1.1em; color:#000; font-weight:bold; line-height:140%; }

a { color:#005fce; text-decoration:none; }
a:hover { color:#005fce; text-decoration:underline; }
a:visited { color:#004aa0; text-decoration:none; }

p { padding:0px; margin:0px 0px 20px; }
img { padding:0px; margin:0px 0px 20px; border:none; }
p img, pre img, tt img, li img, h1 img, h2 img { margin-bottom:0px; } 

ul { padding:0px; margin:0px 0px 20px 23px; list-style:square; }
ul li { padding:0px; margin:0px 0px 7px 0px; }
ul li ul { padding:5px 0px 0px; margin:0px 0px 7px 23px; }
ul li ol li { list-style:decimal; }
ol { padding:0px; margin:0px 0px 20px 0px; list-style:decimal; }
ol li { padding:0px; margin:0px 0px 7px 23px; list-style-type:decimal; }
ol li ol { padding:5px 0px 0px; margin:0px 0px 7px 0px; }
ol li ol li { list-style-type:lower-alpha; }
ol li ul { padding-top:7px; }
ol li ul li { list-style:square; }

.content { font-size:1.2em; line-height:140%; padding: 20px; }

pre, code { font-size:12px; }
tt { font-size: 1.2em; }
pre { margin:0px 0px 20px; }
pre.codeinput { padding:10px; border:1px solid #d3d3d3; background:#f7f7f7; }
pre.codeoutput { padding:10px 11px; margin:0px 0px 20px; color:#4c4c4c; }
pre.error { color:red; }

@media print { pre.codeinput, pre.codeoutput { word-wrap:break-word; width:100%; } }

span.keyword { color:#0000FF }
span.comment { color:#228B22 }
span.string { color:#A020F0 }
span.untermstring { color:#B20000 }
span.syscmd { color:#B28C00 }

.footer { width:auto; padding:10px 0px; margin:25px 0px 0px; border-top:1px dotted #878787; font-size:0.8em; line-height:140%; font-style:italic; color:#878787; text-align:left; float:none; }
.footer p { margin:0px; }
.footer a { color:#878787; }
.footer a:hover { color:#878787; text-decoration:underline; }
.footer a:visited { color:#878787; }

table th { padding:7px 5px; text-align:left; vertical-align:middle; border: 1px solid #d6d4d4; font-weight:bold; }
table td { padding:7px 5px; text-align:left; vertical-align:top; border:1px solid #d6d4d4; }





  </style></head><body><div class="content"><h2>Contents</h2><div><ul><li><a href="#2">part a</a></li><li><a href="#3">part b with BPSK 1/2 Convolutional Encoding</a></li><li><a href="#4">BPSK with BCH 15-7 encoding</a></li><li><a href="#5">QAM with BCH 15-7</a></li></ul></div><pre class="codeinput"><span class="comment">% Matt Kribs, Richard Lee, Lucy Xu</span>
<span class="comment">% Comm Theory Final Project</span>
<span class="comment">% Description: A BER script for a wireless link simulation</span>
</pre><h2 id="2">part a</h2><pre class="codeinput">clear <span class="string">all</span>;clc;close <span class="string">all</span>

<span class="comment">%This section has two parts to it. The first part is matching AWGN</span>
<span class="comment">%performance for M-ary QAM schemes for M = 4 and 16. The second part to</span>
<span class="comment">%this section is to obtain a BER of 10e-4 using BPSK (M=2) after the message</span>
<span class="comment">%bits have been modulated, channeled, added to awgn, equalized, and demodulated.</span>

numIter = 0;              <span class="comment">% number of iterations of the simulation</span>
nSym = 1000;                <span class="comment">% number of symbols per packet</span>
SNR_Vec = 0:2:16;           <span class="comment">% SNR value for the awgn function</span>
lenSNR = length(SNR_Vec);
m_ary = [2, 4, 16];         <span class="comment">% M-ary number, 2 corresponds to binary modulation</span>
<span class="comment">%chan = 1;                  % No channel</span>
chan = [1, 0.2, 0.4];       <span class="comment">% moderate ISI</span>

<span class="comment">% Not so invertible, severe ISI, we did not use this channel for any part</span>
<span class="comment">% of this project</span>
<span class="comment">%chan = [0.227 0.460 0.688 0.460 0.227]';</span>

tic;
trainlen = 300;             <span class="comment">% number of training bits</span>
displayStr = [<span class="string">"BER-2 with ISI"</span>,<span class="string">"BER-4 No ISI"</span>, <span class="string">"BER-16 No ISI"</span>]; <span class="comment">% plot labels</span>

<span class="keyword">for</span> it=1:length(m_ary)
    M = m_ary(it);

    berVec = zeros(numIter, lenSNR);    <span class="comment">% preallocate BER matrix</span>

    <span class="keyword">parfor</span> ii = 1:numIter
        <span class="comment">% we generate a random decimal message everytime</span>
        msg = randi([0, M-1], nSym*(log2(M)), 1);

        <span class="comment">% we turn the msg into bits here</span>
        <span class="comment">% the transpose is so we can columnize</span>
        <span class="comment">% we use bits to for the biterr func, but do not transmit this</span>
        bits = de2bi(msg, <span class="string">'left-msb'</span>).';
        bits = bits(:);

        <span class="keyword">for</span> jj = 1:lenSNR        <span class="comment">% one iteration of the simulation at each SNR Value</span>
            tx = qammod(msg,M);  <span class="comment">% modulate the msg</span>

            <span class="comment">% for 2-ary we filter, add awgn, and equalize</span>
            <span class="keyword">if</span> M == 2

                <span class="comment">% if there is no channel then the received msg is the same</span>
                <span class="comment">% as the transmitted msg</span>
                <span class="keyword">if</span> isequal(chan,1)
                    txChan = tx;
                    txNoisy = txChan;
                <span class="keyword">else</span>
                    txChan = filter(chan,1,tx);         <span class="comment">% apply the channel</span>
                    txNoisy = awgn(txChan,SNR_Vec(jj)); <span class="comment">% add AWGN</span>

                    <span class="comment">% Originally we tried the linear equalizer but could</span>
                    <span class="comment">% not get it down enough, so we switched to dfe</span>

                    <span class="comment">% lineq = comm.LinearEqualizer('Algorithm','LMS', 'NumTaps',6,'StepSize',0.01);</span>
                    <span class="comment">% doesn't work on matlab 2018a</span>

                    <span class="comment">% we also started off with simply feedforward taps but</span>
                    <span class="comment">% it did not work well enough so we used feedback taps</span>
                    <span class="comment">% as well</span>
                    <span class="comment">% eq1 = lineareq(6, lms(0.01));</span>

                    eq1 = dfe(12,6, lms(0.01));
                    eq1.SigConst = qammod(0:M-1, M, <span class="string">'UnitAveragePower'</span>, true);
                    eq1.ResetBeforeFiltering = 1;

                    txNoisy = equalize(eq1,txNoisy,tx(1:trainlen)); <span class="comment">% equalize</span>
                <span class="keyword">end</span>

            <span class="comment">% if we are 4-ary or 16-ary we only add awgn</span>
            <span class="keyword">else</span>
                txNoisy = awgn(tx, SNR_Vec(jj) + 10*log10(log2(M)),<span class="string">'measured'</span>);
            <span class="keyword">end</span>

            rx = qamdemod(txNoisy,M); <span class="comment">% demodulate the signal</span>

            <span class="comment">% Convert the received message to bits</span>
            <span class="comment">% the transpose and the rx(:) is housekeeping - conceptually we are</span>
            <span class="comment">% taking each row, appending it after the previous row, but we do</span>
            <span class="comment">% this transposed since we are working with columns</span>
            rxTmp = de2bi(rx, <span class="string">'left-msb'</span>).';
            rxBits = rxTmp(:);

            <span class="comment">% Compute and store the BER for this iteration</span>
            <span class="comment">% We're interested in the BER, which is the 2nd output of BITERR</span>
            [~, berVec(ii,jj)] = biterr(bits(trainlen+1:end), rxBits(trainlen+1:end));

        <span class="keyword">end</span>  <span class="comment">% End SNR iteration</span>
    <span class="keyword">end</span>      <span class="comment">% End numIter iteration</span>

    <span class="comment">% Compute and plot the mean BER</span>
    ber = mean(berVec,1);

    <span class="comment">% print the BER at SNR = 12 for 2-ary</span>
    <span class="keyword">if</span> M == 2
        BER_at_12 = ber(7)
    <span class="keyword">end</span>

    <span class="comment">% here we plot the figures</span>
    figure(it);
    semilogy(SNR_Vec, ber, <span class="string">'DisplayName'</span>, displayStr(it))
    hold <span class="string">on</span>;

    <span class="comment">% plot different theoreticals depending on M</span>
    <span class="keyword">if</span> M == 2
        berTheory2 = berawgn(SNR_Vec,<span class="string">'psk'</span>, 2,<span class="string">'nondiff'</span>);
        semilogy(SNR_Vec,berTheory2,<span class="string">'DisplayName'</span>, <span class="string">'Theoretical BER for M=2'</span>)
    <span class="keyword">elseif</span> M == 4
        berTheory4 = berawgn(SNR_Vec,<span class="string">'qam'</span>, 4,<span class="string">'nondiff'</span>);
        semilogy(SNR_Vec,berTheory4,<span class="string">'DisplayName'</span>, <span class="string">'Theoretical BER for M=4'</span>)
    <span class="keyword">elseif</span> M == 16
        berTheory16 = berawgn(SNR_Vec,<span class="string">'qam'</span>, 16,<span class="string">'nondiff'</span>);
        semilogy(SNR_Vec,berTheory16, <span class="string">'DisplayName'</span>, <span class="string">'Theoretical BER for M=16'</span>);
    <span class="keyword">end</span>

    legend(<span class="string">'Location'</span>, <span class="string">'southwest'</span>)
    title(<span class="string">'Part A'</span>);
    xlabel(<span class="string">'SNR in dB'</span>);
    ylabel(<span class="string">'Bit Error Rate'</span>);

<span class="keyword">end</span>
fprintf(<span class="string">'Part A: '</span>);
toc
</pre><pre class="codeoutput">BER_at_12 =
   NaN
Part A: Elapsed time is 1.339063 seconds.
</pre><img vspace="5" hspace="5" src="final_tester_01.png" alt=""> <img vspace="5" hspace="5" src="final_tester_02.png" alt=""> <img vspace="5" hspace="5" src="final_tester_03.png" alt=""> <h2 id="3">part b with BPSK 1/2 Convolutional Encoding</h2><pre class="codeinput"><span class="comment">% In this part, an encoding scheme will be added to the system to improve</span>
<span class="comment">% the BER to 10e-6</span>

<span class="comment">% BPSK with 1/2 convolutional encoding</span>
clear <span class="string">all</span>;clc;close <span class="string">all</span>

<span class="comment">% we initially tried 1/2 convolutional encoding since its less tedious to</span>
<span class="comment">% implement than block codes but this proved to not be enough so please</span>
<span class="comment">% find our trials with BCH</span>

<span class="comment">% numIter = 0;</span>
<span class="comment">% nSym = 500;</span>
<span class="comment">% SNR_Vec = 0:2:16;</span>
<span class="comment">% lenSNR = length(SNR_Vec);</span>
<span class="comment">% trainlen = 300;</span>
<span class="comment">% M_values = 2;</span>
<span class="comment">% chan = [1, 0.2, 0.4];</span>
<span class="comment">%</span>
<span class="comment">% displayStr = ["BER-2 with ISI","BER-4 No ISI", "BER-16 No ISI"];</span>
<span class="comment">%</span>
<span class="comment">% tic;</span>
<span class="comment">% for it=1:length(M_values)</span>
<span class="comment">%     m_ary = M_values(it);</span>
<span class="comment">%     berVec = zeros(numIter, lenSNR);</span>
<span class="comment">%     for ii = 1:numIter</span>
<span class="comment">%</span>
<span class="comment">%         msg = randi([0, m_ary-1], nSym*(log2(m_ary)), 1);</span>
<span class="comment">%         numBits = size(msg,1);</span>
<span class="comment">%         % New bits must be generated at every iteration</span>
<span class="comment">%</span>
<span class="comment">%         %encoding 1/2 convolutional</span>
<span class="comment">%         K = 3;                %constraint length is how long a bit can affect the encoder output</span>
<span class="comment">%         g_1 = '1+x+x^2';</span>
<span class="comment">%         g_2 = '1+x^2';</span>
<span class="comment">%         trellis = poly2trellis(K,{g_1,g_2});    %trellis is created</span>
<span class="comment">%         msg_enc = convenc(msg,trellis);         %input bits are encoded</span>
<span class="comment">%</span>
<span class="comment">%         bits = de2bi(msg_enc, 'left-msb').'; %transpose here</span>
<span class="comment">%         bits = bits(:);</span>
<span class="comment">%</span>
<span class="comment">%         for jj = 1:lenSNR               % one iteration of the simulation at each SNR Value</span>
<span class="comment">%             tx = qammod(msg_enc,m_ary); % BPSK modulate the signal</span>
<span class="comment">%</span>
<span class="comment">%             m_ary == 2</span>
<span class="comment">%                 txChan = filter(chan,1,tx);         % apply the channel</span>
<span class="comment">%                 txNoisy = awgn(txChan,SNR_Vec(jj)); % add AWGN</span>
<span class="comment">%</span>
<span class="comment">%                 sigConst = qammod(0:m_ary-1, m_ary, 'UnitAveragePower', true);</span>
<span class="comment">%                 eq1 = dfe(12,6,lms(0.01));</span>
<span class="comment">%                 eq1.SigConst = sigConst;</span>
<span class="comment">%                 eq1.ResetBeforeFiltering = 0;</span>
<span class="comment">%</span>
<span class="comment">%                 txNoisy = equalize(eq1,txNoisy,tx(1:trainlen)); % equalize</span>
<span class="comment">%                 reset(eq1);</span>
<span class="comment">%</span>
<span class="comment">%                 rx = qamdemod(txNoisy,m_ary); %,'OutputType', 'integer'); % Demodulate</span>
<span class="comment">%                 rxTmp = de2bi(rx, 'left-msb').';</span>
<span class="comment">%</span>
<span class="comment">%             tblen = (K - 1)*5;   %positive integer scalar that specifies the traceback depth</span>
<span class="comment">%                                  %for rate 1/2, a typical value for tblen is about</span>
<span class="comment">%                                  %five times the constraint length - 1</span>
<span class="comment">%</span>
<span class="comment">%             rxMSG = (vitdec(rxTmp,trellis,tblen,'trunc','hard')).';</span>
<span class="comment">%             %trunc: encoder is assumed to have started at the all zero state</span>
<span class="comment">%             %hard: code contains binary input values</span>
<span class="comment">%</span>
<span class="comment">%             % Compute and store the BER for this iteration</span>
<span class="comment">%             % We're interested in the BER, which is the 2nd output of BITERR</span>
<span class="comment">%</span>
<span class="comment">%             [~, berVec(ii,jj)] = biterr(msg(trainlen+1:end), rxMSG(trainlen+1:end));</span>
<span class="comment">%</span>
<span class="comment">%         end  % End SNR iteration</span>
<span class="comment">%     end      % End numIter iteration</span>
<span class="comment">% end</span>

<span class="comment">% % Compute and plot the mean BER</span>
<span class="comment">%ber = mean(berVec,1);</span>

<span class="comment">% grab last non zero value and report on screen</span>
<span class="comment">%lowest_non_zero_BER = ber(find(ber,1,'last'))</span>

<span class="comment">% % calculate bit rate</span>
<span class="comment">% bit_rate = (numBits - trainlen)/numBits</span>

<span class="comment">% % plot the figure</span>
<span class="comment">% figure('Name', 'Part B');</span>
<span class="comment">% semilogy(SNR_Vec, ber, 'DisplayName', "BER-2 with ISI")</span>
<span class="comment">% hold on;</span>
<span class="comment">% berTheory2 = berawgn(SNR_Vec,'psk', 2,'nondiff');</span>
<span class="comment">% semilogy(SNR_Vec,berTheory2,'DisplayName', 'Theoretical BER for M=2')</span>
<span class="comment">% legend('Location', 'southwest')</span>
<span class="comment">% title('Reducing Error to 10e-6 for BPSK');</span>
<span class="comment">% xlabel('SNR in dB');</span>
<span class="comment">% ylabel('Bit Error Rate');</span>
<span class="comment">% fprintf('Part B: ');</span>
<span class="comment">% toc</span>
</pre><h2 id="4">BPSK with BCH 15-7 encoding</h2><pre class="codeinput"><span class="comment">%clc;clear;close all</span>
<span class="comment">%</span>
<span class="comment">% % We thought that we had to stick to BPSK (2-ary) so we have this section</span>
<span class="comment">% % where we used BCH 15-7 encoding on 2-ary but after we realized we could</span>
<span class="comment">% % have used QAM, we tried that out in the next section</span>
<span class="comment">%</span>
<span class="comment">% numIterations = 1;</span>
<span class="comment">% numSymbols = 1000;</span>
<span class="comment">%</span>
<span class="comment">% % We are allowed roughly 1000 symbols: we use this to find roughly how many words</span>
<span class="comment">% % we can generate for BCH 15-7</span>
<span class="comment">% % we use a ceiling function below to calculate precisely how many codewords</span>
<span class="comment">% % we can send</span>
<span class="comment">%</span>
<span class="comment">% % fter encoding, the number of total bits (including parity) that we use for training</span>
<span class="comment">% numTraining = 150;</span>
<span class="comment">%</span>
<span class="comment">% SNR_Vec = 0:2:16;</span>
<span class="comment">% SNRlen = length(SNR_Vec);</span>
<span class="comment">%</span>
<span class="comment">% % same channel, Moderate ISI</span>
<span class="comment">% chan = [1, 0.2, 0.4];</span>
<span class="comment">%</span>
<span class="comment">% tic;</span>
<span class="comment">%</span>
<span class="comment">% M = 2;</span>
<span class="comment">% codeWordLen = 15;</span>
<span class="comment">% msgLen = 7;</span>
<span class="comment">%</span>
<span class="comment">% % the ceiling is to round up the number of words</span>
<span class="comment">%</span>
<span class="comment">% % later, we use num words * msgLen to figure out how many bits we can</span>
<span class="comment">% % generate, knowing that encoding will add 8 parity bits to each symbol</span>
<span class="comment">% numWords = ceil(numSymbols/codeWordLen);</span>
<span class="comment">%</span>
<span class="comment">% % number of training bits that we had to take from the original message</span>
<span class="comment">% trainingBits = (numTraining/codeWordLen) * msgLen;</span>
<span class="comment">%</span>
<span class="comment">% % make a 0 vector</span>
<span class="comment">% BERvec2 = zeros(numIterations, SNRlen);</span>
<span class="comment">%</span>
<span class="comment">% % We use the comm BCH encoder and decoder objects, make them once and reuse</span>
<span class="comment">% enc = comm.BCHEncoder(codeWordLen, msgLen);</span>
<span class="comment">% dec = comm.BCHDecoder(codeWordLen, msgLen);</span>
<span class="comment">%</span>
<span class="comment">% for ii=1:numIterations</span>
<span class="comment">%     % make a msg that is number of msg bits long, such that after encoding,</span>
<span class="comment">%     % there are approximately 100- symbols transmitted</span>
<span class="comment">%     msg = randi([0, M-1], msgLen * numWords, 1);</span>
<span class="comment">%     numBits = size(msg,1);</span>
<span class="comment">%</span>
<span class="comment">%     % BCH encode it. 469 bits generated above, 1005 symbols transmitted</span>
<span class="comment">%     msg_enc = step(enc, msg);</span>
<span class="comment">%</span>
<span class="comment">%     for jj=1:SNRlen</span>
<span class="comment">%</span>
<span class="comment">%         tx = qammod(msg_enc, M);            % modulate the signal</span>
<span class="comment">%         txChan = filter(chan,1,tx);         % apply the channel</span>
<span class="comment">%         txNoisy = awgn(txChan,SNR_Vec(jj)); % add AWGN</span>
<span class="comment">%</span>
<span class="comment">%         eq1 = dfe(12,6, lms(0.01));         % create equalizer object</span>
<span class="comment">%         eq1.SigConst = qammod(0:M-1, M, 'UnitAveragePower', true);</span>
<span class="comment">%         eq1.ResetBeforeFiltering = 1;</span>
<span class="comment">%</span>
<span class="comment">%         txNoisy = equalize(eq1,txNoisy,tx(1:numTraining));  % equalize</span>
<span class="comment">%         rx = qamdemod(txNoisy, M);                          % demodulate</span>
<span class="comment">%         dec_msg = step(dec, rx);                            % decode</span>
<span class="comment">%</span>
<span class="comment">%         % calculate BER</span>
<span class="comment">%         [~, BERvec2(ii,jj)] = biterr(msg(trainingBits+1:end), dec_msg(trainingBits+1:end));</span>
<span class="comment">%     end</span>
<span class="comment">% end</span>
<span class="comment">%</span>
<span class="comment">% % average BER for each SNR</span>
<span class="comment">%ber2 = mean(BERvec2,1);</span>
<span class="comment">%</span>
<span class="comment">% % grab last non zero value and report on screen</span>
<span class="comment">% lowest_non_zero_BER = ber2(find(ber2,1,'last'))</span>
<span class="comment">%</span>
<span class="comment">% % calculate bit rate</span>
<span class="comment">% bit_rate = (numBits - trainingBits)/numBits</span>
<span class="comment">%</span>
<span class="comment">% % plot the figure</span>
<span class="comment">% figure('Name', 'Part B');</span>
<span class="comment">% semilogy(SNR_Vec, ber2, 'DisplayName', "BER-2 with ISI")</span>
<span class="comment">% hold on;</span>
<span class="comment">% berTheory2 = berawgn(SNR_Vec,'psk', 2,'nondiff');</span>
<span class="comment">% semilogy(SNR_Vec,berTheory2,'DisplayName', 'Theoretical BER for M=2')</span>
<span class="comment">% legend('Location', 'southwest')</span>
<span class="comment">% title('Reducing Error to 10e-6 for BPSK');</span>
<span class="comment">% xlabel('SNR in dB');</span>
<span class="comment">% ylabel('Bit Error Rate');</span>
<span class="comment">% fprintf('Part B: ');</span>
<span class="comment">% toc</span>
</pre><h2 id="5">QAM with BCH 15-7</h2><pre class="codeinput">pp = 1:90

qq= 15*pp

<span class="keyword">for</span> kk=qq

    kk

    <span class="comment">%clc;clear;close all</span>

    <span class="comment">% QAM with 4-ary should be able to imporve the bit rate because the number</span>
    <span class="comment">% of bits per symbol is doubled</span>

    <span class="comment">% same parameters from part a</span>
    numIterations = 10000;
    numSym = 1000;
    SNR_Vec = 12;
    SNRlen = length(SNR_Vec);
    chan = [1, 0.2, 0.4];

    <span class="comment">% number of codewords*2 that is used for training</span>
    n = 60;
    <span class="comment">% number of symbols that is used for training aka number of msg bits*2</span>
    <span class="comment">% that is used for training</span>
    numTraining = kk;

    M = 4;
    codeWordLen = 15;
    msgLen = 7;

    <span class="comment">% 286 codewords transmitted for the given parameters which is 286*7 = 2002</span>
    <span class="comment">% bits aka 1001 symbols</span>
    numWords = ceil(numSym*log2(M)/msgLen);

    <span class="comment">% number of bits from 'msg' that have to be used for training</span>
    trainingBits = log2(M)*(numTraining/codeWordLen) * msgLen;

    tic;
    <span class="comment">% preallocate BER matrix like previously</span>
    BERvec2 = zeros(numIterations, SNRlen);
    numBits = msgLen*numWords;

    <span class="comment">% create encoder and decoder objects for the given BCH parameters</span>
    enc = comm.BCHEncoder(codeWordLen, msgLen);
    dec = comm.BCHDecoder(codeWordLen, msgLen);

    <span class="keyword">parfor</span> ii=1:numIterations

        <span class="comment">% total bits we can generate is numWords*msgLen = 2002 bits = 1001 symbols</span>
        msg = randi([0, 1], msgLen*numWords, 1);

        <span class="comment">% encode msg with parity bits inserted after every 7 bits aka every</span>
        <span class="comment">% message</span>
        msg_enc = step(enc, msg);
        a = msg_enc;                <span class="comment">% checkpoint</span>

        <span class="comment">% pair up the bits to convert to decimal</span>
        msg_enc = reshape(msg_enc,log2(M),length(msg_enc)/log2(M)).';
        b = msg_enc;                <span class="comment">% checkpoint</span>

        <span class="comment">% convert to decimal</span>
        msg_enc = bi2de(msg_enc);

        <span class="keyword">for</span> jj=1:SNRlen
            <span class="comment">% qammod default parameters is gray code ordering and integer inputs</span>
            tx = qammod(msg_enc, M, <span class="string">'UnitAveragePower'</span>, true);

                txChan = filter(chan,1,tx);         <span class="comment">% apply the channel</span>
                txNoisy = awgn(txChan,SNR_Vec(jj),<span class="string">'measured'</span>); <span class="comment">% add awgn</span>

                eq1 = dfe(12,6, lms(0.01));         <span class="comment">% create equalizer objecct</span>
                eq1.SigConst = qammod(0:M-1, M, <span class="string">'UnitAveragePower'</span>, true);
                eq1.ResetBeforeFiltering = 1;

                txNoisy = equalize(eq1,txNoisy,tx(1:numTraining));  <span class="comment">% equalize</span>

            rx = qamdemod(txNoisy, M, <span class="string">'UnitAveragePower'</span>, true);    <span class="comment">% demodulate</span>

            <span class="comment">% convert back to binary so that recieved msg can be decoded</span>
            rxTmp = (de2bi(rx)).';
            rxMsg = rxTmp(:);           <span class="comment">% columnize</span>

            dec_msg = step(dec, rxMsg); <span class="comment">% decode</span>

            <span class="comment">% calculate BER</span>
            [~, BERvec2(ii,jj)] = biterr(msg(trainingBits+1:end), dec_msg(trainingBits+1:end));
        <span class="keyword">end</span>
    <span class="keyword">end</span>

    ber2 = mean(BERvec2,1);

    <span class="comment">%figure;</span>
    <span class="comment">%semilogy(SNR_Vec, ber2, 'DisplayName', "BER-4 with ISI")</span>
    <span class="comment">%title('Part B')</span>
    <span class="comment">%hold on;</span>
    <span class="comment">%berTheory2 = berawgn(SNR_Vec,'qam', 4,'nondiff');</span>
    <span class="comment">%semilogy(SNR_Vec,berTheory2,'DisplayName', 'Theoretical BER for M=4')</span>
    <span class="comment">%legend('Location', 'southwest')</span>
    <span class="comment">%fprintf('Part B: ');</span>
    <span class="comment">%toc</span>

    bit_rate = (numBits - trainingBits)/numBits

    <span class="comment">% grab last non zero value of BER vector</span>
    lowest_non_zero_BER = ber2(find(ber2,1,<span class="string">'last'</span>))
    ber2(1)

<span class="keyword">end</span>
</pre><pre class="codeoutput">pp =
  Columns 1 through 13
     1     2     3     4     5     6     7     8     9    10    11    12    13
  Columns 14 through 26
    14    15    16    17    18    19    20    21    22    23    24    25    26
  Columns 27 through 39
    27    28    29    30    31    32    33    34    35    36    37    38    39
  Columns 40 through 52
    40    41    42    43    44    45    46    47    48    49    50    51    52
  Columns 53 through 65
    53    54    55    56    57    58    59    60    61    62    63    64    65
  Columns 66 through 78
    66    67    68    69    70    71    72    73    74    75    76    77    78
  Columns 79 through 90
    79    80    81    82    83    84    85    86    87    88    89    90
qq =
  Columns 1 through 6
          15          30          45          60          75          90
  Columns 7 through 12
         105         120         135         150         165         180
  Columns 13 through 18
         195         210         225         240         255         270
  Columns 19 through 24
         285         300         315         330         345         360
  Columns 25 through 30
         375         390         405         420         435         450
  Columns 31 through 36
         465         480         495         510         525         540
  Columns 37 through 42
         555         570         585         600         615         630
  Columns 43 through 48
         645         660         675         690         705         720
  Columns 49 through 54
         735         750         765         780         795         810
  Columns 55 through 60
         825         840         855         870         885         900
  Columns 61 through 66
         915         930         945         960         975         990
  Columns 67 through 72
        1005        1020        1035        1050        1065        1080
  Columns 73 through 78
        1095        1110        1125        1140        1155        1170
  Columns 79 through 84
        1185        1200        1215        1230        1245        1260
  Columns 85 through 90
        1275        1290        1305        1320        1335        1350
kk =
    15
Starting parallel pool (parpool) using the 'local' profile ...
Connected to the parallel pool (number of workers: 8).
bit_rate =
    0.9930
lowest_non_zero_BER =
    0.4955
ans =
    0.4955
kk =
    30
bit_rate =
    0.9860
lowest_non_zero_BER =
    0.3759
ans =
    0.3759
kk =
    45
bit_rate =
    0.9790
lowest_non_zero_BER =
    0.0922
ans =
    0.0922
kk =
    60
bit_rate =
    0.9720
lowest_non_zero_BER =
    0.0067
ans =
    0.0067
kk =
    75
bit_rate =
    0.9650
lowest_non_zero_BER =
   4.4208e-04
ans =
   4.4208e-04
kk =
    90
bit_rate =
    0.9580
lowest_non_zero_BER =
   1.8352e-05
ans =
   1.8352e-05
kk =
   105
bit_rate =
    0.9510
lowest_non_zero_BER =
   5.9874e-06
ans =
   5.9874e-06
kk =
   120
bit_rate =
    0.9441
lowest_non_zero_BER =
   3.2804e-06
ans =
   3.2804e-06
kk =
   135
bit_rate =
    0.9371
lowest_non_zero_BER =
   2.8785e-06
ans =
   2.8785e-06
kk =
   150
bit_rate =
    0.9301
lowest_non_zero_BER =
   2.4705e-06
ans =
   2.4705e-06
kk =
   165
bit_rate =
    0.9231
lowest_non_zero_BER =
   2.9221e-06
ans =
   2.9221e-06
kk =
   180
bit_rate =
    0.9161
lowest_non_zero_BER =
   2.8899e-06
ans =
   2.8899e-06
kk =
   195
bit_rate =
    0.9091
lowest_non_zero_BER =
   3.2967e-06
ans =
   3.2967e-06
kk =
   210
bit_rate =
    0.9021
lowest_non_zero_BER =
   3.4330e-06
ans =
   3.4330e-06
kk =
   225
bit_rate =
    0.8951
lowest_non_zero_BER =
   3.2924e-06
ans =
   3.2924e-06
kk =
   240
bit_rate =
    0.8881
lowest_non_zero_BER =
   3.4871e-06
ans =
   3.4871e-06
kk =
   255
bit_rate =
    0.8811
lowest_non_zero_BER =
   4.2517e-06
ans =
   4.2517e-06
kk =
   270
bit_rate =
    0.8741
lowest_non_zero_BER =
   3.0857e-06
ans =
   3.0857e-06
kk =
   285
bit_rate =
    0.8671
lowest_non_zero_BER =
   3.1682e-06
ans =
   3.1682e-06
kk =
   300
bit_rate =
    0.8601
lowest_non_zero_BER =
   3.3101e-06
ans =
   3.3101e-06
kk =
   315
bit_rate =
    0.8531
lowest_non_zero_BER =
   3.2787e-06
ans =
   3.2787e-06
kk =
   330
bit_rate =
    0.8462
lowest_non_zero_BER =
   2.6564e-06
ans =
   2.6564e-06
kk =
   345
bit_rate =
    0.8392
lowest_non_zero_BER =
   2.7381e-06
ans =
   2.7381e-06
kk =
   360
bit_rate =
    0.8322
lowest_non_zero_BER =
   3.0012e-06
ans =
   3.0012e-06
kk =
   375
bit_rate =
    0.8252
lowest_non_zero_BER =
   2.6029e-06
ans =
   2.6029e-06
kk =
   390
bit_rate =
    0.8182
lowest_non_zero_BER =
   3.9072e-06
ans =
   3.9072e-06
kk =
   405
bit_rate =
    0.8112
lowest_non_zero_BER =
   3.3867e-06
ans =
   3.3867e-06
kk =
   420
bit_rate =
    0.8042
lowest_non_zero_BER =
   3.5404e-06
ans =
   3.5404e-06
kk =
   435
bit_rate =
    0.7972
lowest_non_zero_BER =
   3.3208e-06
ans =
   3.3208e-06
kk =
   450
bit_rate =
    0.7902
lowest_non_zero_BER =
   1.8331e-06
ans =
   1.8331e-06
kk =
   465
bit_rate =
    0.7832
lowest_non_zero_BER =
   2.8699e-06
ans =
   2.8699e-06
kk =
   480
bit_rate =
    0.7762
lowest_non_zero_BER =
   4.8906e-06
ans =
   4.8906e-06
kk =
   495
bit_rate =
    0.7692
lowest_non_zero_BER =
   3.5714e-06
ans =
   3.5714e-06
kk =
   510
bit_rate =
    0.7622
lowest_non_zero_BER =
   3.2110e-06
ans =
   3.2110e-06
kk =
   525
bit_rate =
    0.7552
lowest_non_zero_BER =
   3.2407e-06
ans =
   3.2407e-06
kk =
   540
bit_rate =
    0.7483
lowest_non_zero_BER =
   4.0053e-06
ans =
   4.0053e-06
kk =
   555
bit_rate =
    0.7413
lowest_non_zero_BER =
   3.0997e-06
ans =
   3.0997e-06
kk =
   570
bit_rate =
    0.7343
lowest_non_zero_BER =
   4.2857e-06
ans =
   4.2857e-06
kk =
   585
bit_rate =
    0.7273
lowest_non_zero_BER =
   5.0824e-06
ans =
   5.0824e-06
kk =
   600
bit_rate =
    0.7203
lowest_non_zero_BER =
   3.6755e-06
ans =
   3.6755e-06
kk =
   615
bit_rate =
    0.7133
lowest_non_zero_BER =
   3.1513e-06
ans =
   3.1513e-06
kk =
   630
bit_rate =
    0.7063
lowest_non_zero_BER =
   1.9802e-06
ans =
   1.9802e-06
kk =
   645
bit_rate =
    0.6993
lowest_non_zero_BER =
   5.4286e-06
ans =
   5.4286e-06
kk =
   660
bit_rate =
    0.6923
lowest_non_zero_BER =
   2.8139e-06
ans =
   2.8139e-06
kk =
   675
bit_rate =
    0.6853
lowest_non_zero_BER =
   3.3528e-06
ans =
   3.3528e-06
kk =
   690
bit_rate =
    0.6783
lowest_non_zero_BER =
   3.3137e-06
ans =
   3.3137e-06
kk =
   705
bit_rate =
    0.6713
lowest_non_zero_BER =
   3.0506e-06
ans =
   3.0506e-06
kk =
   720
bit_rate =
    0.6643
lowest_non_zero_BER =
   5.0376e-06
ans =
   5.0376e-06
kk =
   735
bit_rate =
    0.6573
lowest_non_zero_BER =
   4.4073e-06
ans =
   4.4073e-06
kk =
   750
bit_rate =
    0.6503
lowest_non_zero_BER =
   1.6897e-06
ans =
   1.6897e-06
kk =
   765
bit_rate =
    0.6434
lowest_non_zero_BER =
   4.4255e-06
ans =
   4.4255e-06
kk =
   780
bit_rate =
    0.6364
lowest_non_zero_BER =
   4.8666e-06
ans =
   4.8666e-06
kk =
   795
bit_rate =
    0.6294
lowest_non_zero_BER =
   2.7778e-06
ans =
   2.7778e-06
kk =
   810
bit_rate =
    0.6224
lowest_non_zero_BER =
   1.8459e-06
ans =
   1.8459e-06
kk =
   825
bit_rate =
    0.6154
lowest_non_zero_BER =
   4.4643e-06
ans =
   4.4643e-06
kk =
   840
bit_rate =
    0.6084
lowest_non_zero_BER =
   2.2167e-06
ans =
   2.2167e-06
kk =
   855
bit_rate =
    0.6014
lowest_non_zero_BER =
   2.4086e-06
ans =
   2.4086e-06
kk =
   870
bit_rate =
    0.5944
lowest_non_zero_BER =
   3.8655e-06
ans =
   3.8655e-06
kk =
   885
bit_rate =
    0.5874
lowest_non_zero_BER =
   3.6565e-06
ans =
   3.6565e-06
kk =
   900
bit_rate =
    0.5804
lowest_non_zero_BER =
   4.3890e-06
ans =
   4.3890e-06
kk =
   915
bit_rate =
    0.5734
lowest_non_zero_BER =
   3.2230e-06
ans =
   3.2230e-06
kk =
   930
bit_rate =
    0.5664
lowest_non_zero_BER =
   1.9400e-06
ans =
   1.9400e-06
kk =
   945
bit_rate =
    0.5594
lowest_non_zero_BER =
   3.9286e-06
ans =
   3.9286e-06
kk =
   960
bit_rate =
    0.5524
lowest_non_zero_BER =
   4.3400e-06
ans =
   4.3400e-06
kk =
   975
bit_rate =
    0.5455
lowest_non_zero_BER =
   2.9304e-06
ans =
   2.9304e-06
kk =
   990
bit_rate =
    0.5385
lowest_non_zero_BER =
   2.7829e-06
ans =
   2.7829e-06
kk =
        1005
bit_rate =
    0.5315
lowest_non_zero_BER =
   2.1617e-06
ans =
   2.1617e-06
kk =
        1020
bit_rate =
    0.5245
lowest_non_zero_BER =
   4.0000e-06
ans =
   4.0000e-06
kk =
        1035
bit_rate =
    0.5175
lowest_non_zero_BER =
   2.6062e-06
ans =
   2.6062e-06
kk =
        1050
bit_rate =
    0.5105
lowest_non_zero_BER =
   4.4031e-06
ans =
   4.4031e-06
kk =
        1065
bit_rate =
    0.5035
lowest_non_zero_BER =
   3.9683e-06
ans =
   3.9683e-06
kk =
        1080
bit_rate =
    0.4965
lowest_non_zero_BER =
   1.9115e-06
ans =
   1.9115e-06
kk =
        1095
bit_rate =
    0.4895
lowest_non_zero_BER =
   4.4898e-06
ans =
   4.4898e-06
kk =
        1110
bit_rate =
    0.4825
lowest_non_zero_BER =
   3.3126e-06
ans =
   3.3126e-06
kk =
        1125
bit_rate =
    0.4755
lowest_non_zero_BER =
   5.7773e-06
ans =
   5.7773e-06
kk =
        1140
bit_rate =
    0.4685
lowest_non_zero_BER =
   5.3305e-06
ans =
   5.3305e-06
kk =
        1155
bit_rate =
    0.4615
lowest_non_zero_BER =
   4.9784e-06
ans =
   4.9784e-06
kk =
        1170
bit_rate =
    0.4545
lowest_non_zero_BER =
   5.9341e-06
ans =
   5.9341e-06
kk =
        1185
bit_rate =
    0.4476
lowest_non_zero_BER =
   3.2366e-06
ans =
   3.2366e-06
kk =
        1200
bit_rate =
    0.4406
lowest_non_zero_BER =
   4.7619e-06
ans =
   4.7619e-06
kk =
        1215
bit_rate =
    0.4336
lowest_non_zero_BER =
   4.4931e-06
ans =
   4.4931e-06
kk =
        1230
bit_rate =
    0.4266
lowest_non_zero_BER =
   3.6300e-06
ans =
   3.6300e-06
kk =
        1245
bit_rate =
    0.4196
lowest_non_zero_BER =
   5.1190e-06
ans =
   5.1190e-06
kk =
        1260
bit_rate =
    0.4126
lowest_non_zero_BER =
   5.0847e-06
ans =
   5.0847e-06
kk =
        1275
bit_rate =
    0.4056
lowest_non_zero_BER =
   3.6946e-06
ans =
   3.6946e-06
kk =
        1290
bit_rate =
    0.3986
lowest_non_zero_BER =
   2.5063e-06
ans =
   2.5063e-06
kk =
        1305
bit_rate =
    0.3916
lowest_non_zero_BER =
   4.9745e-06
ans =
   4.9745e-06
kk =
        1320
bit_rate =
    0.3846
lowest_non_zero_BER =
   3.5065e-06
ans =
   3.5065e-06
kk =
        1335
bit_rate =
    0.3776
lowest_non_zero_BER =
   2.5132e-06
ans =
   2.5132e-06
kk =
        1350
bit_rate =
    0.3706
lowest_non_zero_BER =
   2.5606e-06
ans =
   2.5606e-06
</pre><p class="footer"><br><a href="https://www.mathworks.com/products/matlab/">Published with MATLAB&reg; R2019b</a><br></p></div><!--
##### SOURCE BEGIN #####
% Matt Kribs, Richard Lee, Lucy Xu
% Comm Theory Final Project
% Description: A BER script for a wireless link simulation

%% part a
clear all;clc;close all

%This section has two parts to it. The first part is matching AWGN
%performance for M-ary QAM schemes for M = 4 and 16. The second part to
%this section is to obtain a BER of 10e-4 using BPSK (M=2) after the message
%bits have been modulated, channeled, added to awgn, equalized, and demodulated.

numIter = 0;              % number of iterations of the simulation
nSym = 1000;                % number of symbols per packet
SNR_Vec = 0:2:16;           % SNR value for the awgn function
lenSNR = length(SNR_Vec);   
m_ary = [2, 4, 16];         % M-ary number, 2 corresponds to binary modulation
%chan = 1;                  % No channel
chan = [1, 0.2, 0.4];       % moderate ISI

% Not so invertible, severe ISI, we did not use this channel for any part
% of this project
%chan = [0.227 0.460 0.688 0.460 0.227]';   

tic;
trainlen = 300;             % number of training bits 
displayStr = ["BER-2 with ISI","BER-4 No ISI", "BER-16 No ISI"]; % plot labels

for it=1:length(m_ary)
    M = m_ary(it);
    
    berVec = zeros(numIter, lenSNR);    % preallocate BER matrix
    
    parfor ii = 1:numIter
        % we generate a random decimal message everytime
        msg = randi([0, M-1], nSym*(log2(M)), 1);  
 
        % we turn the msg into bits here
        % the transpose is so we can columnize
        % we use bits to for the biterr func, but do not transmit this 
        bits = de2bi(msg, 'left-msb').'; 
        bits = bits(:);
        
        for jj = 1:lenSNR        % one iteration of the simulation at each SNR Value
            tx = qammod(msg,M);  % modulate the msg
               
            % for 2-ary we filter, add awgn, and equalize
            if M == 2
                
                % if there is no channel then the received msg is the same
                % as the transmitted msg
                if isequal(chan,1) 
                    txChan = tx;
                    txNoisy = txChan;
                else
                    txChan = filter(chan,1,tx);         % apply the channel
                    txNoisy = awgn(txChan,SNR_Vec(jj)); % add AWGN
                               
                    % Originally we tried the linear equalizer but could
                    % not get it down enough, so we switched to dfe
                   
                    % lineq = comm.LinearEqualizer('Algorithm','LMS', 'NumTaps',6,'StepSize',0.01); 
                    % doesn't work on matlab 2018a
                    
                    % we also started off with simply feedforward taps but
                    % it did not work well enough so we used feedback taps
                    % as well
                    % eq1 = lineareq(6, lms(0.01));
                    
                    eq1 = dfe(12,6, lms(0.01)); 
                    eq1.SigConst = qammod(0:M-1, M, 'UnitAveragePower', true);
                    eq1.ResetBeforeFiltering = 1;
            
                    txNoisy = equalize(eq1,txNoisy,tx(1:trainlen)); % equalize
                end
                
            % if we are 4-ary or 16-ary we only add awgn
            else 
                txNoisy = awgn(tx, SNR_Vec(jj) + 10*log10(log2(M)),'measured');
            end
            
            rx = qamdemod(txNoisy,M); % demodulate the signal
            
            % Convert the received message to bits
            % the transpose and the rx(:) is housekeeping - conceptually we are
            % taking each row, appending it after the previous row, but we do
            % this transposed since we are working with columns
            rxTmp = de2bi(rx, 'left-msb').'; 
            rxBits = rxTmp(:);
            
            % Compute and store the BER for this iteration
            % We're interested in the BER, which is the 2nd output of BITERR
            [~, berVec(ii,jj)] = biterr(bits(trainlen+1:end), rxBits(trainlen+1:end));  
            
        end  % End SNR iteration
    end      % End numIter iteration
    
    % Compute and plot the mean BER
    ber = mean(berVec,1);
    
    % print the BER at SNR = 12 for 2-ary
    if M == 2
        BER_at_12 = ber(7)
    end
    
    % here we plot the figures
    figure(it);
    semilogy(SNR_Vec, ber, 'DisplayName', displayStr(it))
    hold on;
    
    % plot different theoreticals depending on M
    if M == 2
        berTheory2 = berawgn(SNR_Vec,'psk', 2,'nondiff');
        semilogy(SNR_Vec,berTheory2,'DisplayName', 'Theoretical BER for M=2')
    elseif M == 4
        berTheory4 = berawgn(SNR_Vec,'qam', 4,'nondiff');
        semilogy(SNR_Vec,berTheory4,'DisplayName', 'Theoretical BER for M=4')
    elseif M == 16
        berTheory16 = berawgn(SNR_Vec,'qam', 16,'nondiff');
        semilogy(SNR_Vec,berTheory16, 'DisplayName', 'Theoretical BER for M=16');
    end
    
    legend('Location', 'southwest')
    title('Part A');
    xlabel('SNR in dB');
    ylabel('Bit Error Rate');
    
end
fprintf('Part A: ');
toc

%% part b with BPSK 1/2 Convolutional Encoding

% In this part, an encoding scheme will be added to the system to improve
% the BER to 10e-6

% BPSK with 1/2 convolutional encoding
clear all;clc;close all

% we initially tried 1/2 convolutional encoding since its less tedious to
% implement than block codes but this proved to not be enough so please
% find our trials with BCH

% numIter = 0;
% nSym = 500;    
% SNR_Vec = 0:2:16;
% lenSNR = length(SNR_Vec);
% trainlen = 300;      
% M_values = 2;
% chan = [1, 0.2, 0.4];
% 
% displayStr = ["BER-2 with ISI","BER-4 No ISI", "BER-16 No ISI"];
% 
% tic;
% for it=1:length(M_values)
%     m_ary = M_values(it);
%     berVec = zeros(numIter, lenSNR);
%     for ii = 1:numIter
% 
%         msg = randi([0, m_ary-1], nSym*(log2(m_ary)), 1); 
%         numBits = size(msg,1);
%         % New bits must be generated at every iteration
% 
%         %encoding 1/2 convolutional
%         K = 3;                %constraint length is how long a bit can affect the encoder output
%         g_1 = '1+x+x^2';                
%         g_2 = '1+x^2';        
%         trellis = poly2trellis(K,{g_1,g_2});    %trellis is created 
%         msg_enc = convenc(msg,trellis);         %input bits are encoded
%         
%         bits = de2bi(msg_enc, 'left-msb').'; %transpose here 
%         bits = bits(:);
%         
%         for jj = 1:lenSNR               % one iteration of the simulation at each SNR Value
%             tx = qammod(msg_enc,m_ary); % BPSK modulate the signal
%             
%             m_ary == 2
%                 txChan = filter(chan,1,tx);         % apply the channel
%                 txNoisy = awgn(txChan,SNR_Vec(jj)); % add AWGN
%                     
%                 sigConst = qammod(0:m_ary-1, m_ary, 'UnitAveragePower', true);
%                 eq1 = dfe(12,6,lms(0.01)); 
%                 eq1.SigConst = sigConst; 
%                 eq1.ResetBeforeFiltering = 0;
%                    
%                 txNoisy = equalize(eq1,txNoisy,tx(1:trainlen)); % equalize
%                 reset(eq1);
%                     
%                 rx = qamdemod(txNoisy,m_ary); %,'OutputType', 'integer'); % Demodulate
%                 rxTmp = de2bi(rx, 'left-msb').'; 
%                 
%             tblen = (K - 1)*5;   %positive integer scalar that specifies the traceback depth
%                                  %for rate 1/2, a typical value for tblen is about
%                                  %five times the constraint length - 1
%                                       
%             rxMSG = (vitdec(rxTmp,trellis,tblen,'trunc','hard')).';
%             %trunc: encoder is assumed to have started at the all zero state
%             %hard: code contains binary input values                         
%             
%             % Compute and store the BER for this iteration
%             % We're interested in the BER, which is the 2nd output of BITERR
% 
%             [~, berVec(ii,jj)] = biterr(msg(trainlen+1:end), rxMSG(trainlen+1:end)); 
% 
%         end  % End SNR iteration
%     end      % End numIter iteration
% end

% % Compute and plot the mean BER
%ber = mean(berVec,1);
    
% grab last non zero value and report on screen
%lowest_non_zero_BER = ber(find(ber,1,'last'))

% % calculate bit rate
% bit_rate = (numBits - trainlen)/numBits

% % plot the figure
% figure('Name', 'Part B');
% semilogy(SNR_Vec, ber, 'DisplayName', "BER-2 with ISI")
% hold on;
% berTheory2 = berawgn(SNR_Vec,'psk', 2,'nondiff');
% semilogy(SNR_Vec,berTheory2,'DisplayName', 'Theoretical BER for M=2')
% legend('Location', 'southwest')
% title('Reducing Error to 10e-6 for BPSK');
% xlabel('SNR in dB');
% ylabel('Bit Error Rate');
% fprintf('Part B: ');
% toc

%% BPSK with BCH 15-7 encoding
%clc;clear;close all
% 
% % We thought that we had to stick to BPSK (2-ary) so we have this section
% % where we used BCH 15-7 encoding on 2-ary but after we realized we could
% % have used QAM, we tried that out in the next section
% 
% numIterations = 1;  
% numSymbols = 1000;
% 
% % We are allowed roughly 1000 symbols: we use this to find roughly how many words
% % we can generate for BCH 15-7
% % we use a ceiling function below to calculate precisely how many codewords
% % we can send
%  
% % fter encoding, the number of total bits (including parity) that we use for training
% numTraining = 150;
% 
% SNR_Vec = 0:2:16; 
% SNRlen = length(SNR_Vec);
% 
% % same channel, Moderate ISI
% chan = [1, 0.2, 0.4];
% 
% tic;
% 
% M = 2;
% codeWordLen = 15;
% msgLen = 7;
% 
% % the ceiling is to round up the number of words
% 
% % later, we use num words * msgLen to figure out how many bits we can
% % generate, knowing that encoding will add 8 parity bits to each symbol
% numWords = ceil(numSymbols/codeWordLen);
% 
% % number of training bits that we had to take from the original message
% trainingBits = (numTraining/codeWordLen) * msgLen;
% 
% % make a 0 vector
% BERvec2 = zeros(numIterations, SNRlen);
% 
% % We use the comm BCH encoder and decoder objects, make them once and reuse
% enc = comm.BCHEncoder(codeWordLen, msgLen);
% dec = comm.BCHDecoder(codeWordLen, msgLen);
% 
% for ii=1:numIterations
%     % make a msg that is number of msg bits long, such that after encoding, 
%     % there are approximately 100- symbols transmitted 
%     msg = randi([0, M-1], msgLen * numWords, 1);
%     numBits = size(msg,1);
%     
%     % BCH encode it. 469 bits generated above, 1005 symbols transmitted
%     msg_enc = step(enc, msg);
%     
%     for jj=1:SNRlen
%         
%         tx = qammod(msg_enc, M);            % modulate the signal
%         txChan = filter(chan,1,tx);         % apply the channel
%         txNoisy = awgn(txChan,SNR_Vec(jj)); % add AWGN
%         
%         eq1 = dfe(12,6, lms(0.01));         % create equalizer object
%         eq1.SigConst = qammod(0:M-1, M, 'UnitAveragePower', true);
%         eq1.ResetBeforeFiltering = 1;
%        
%         txNoisy = equalize(eq1,txNoisy,tx(1:numTraining));  % equalize
%         rx = qamdemod(txNoisy, M);                          % demodulate
%         dec_msg = step(dec, rx);                            % decode
%         
%         % calculate BER
%         [~, BERvec2(ii,jj)] = biterr(msg(trainingBits+1:end), dec_msg(trainingBits+1:end));  
%     end
% end
% 
% % average BER for each SNR
%ber2 = mean(BERvec2,1);
% 
% % grab last non zero value and report on screen
% lowest_non_zero_BER = ber2(find(ber2,1,'last'))
% 
% % calculate bit rate
% bit_rate = (numBits - trainingBits)/numBits
% 
% % plot the figure
% figure('Name', 'Part B');
% semilogy(SNR_Vec, ber2, 'DisplayName', "BER-2 with ISI")
% hold on;
% berTheory2 = berawgn(SNR_Vec,'psk', 2,'nondiff');
% semilogy(SNR_Vec,berTheory2,'DisplayName', 'Theoretical BER for M=2')
% legend('Location', 'southwest')
% title('Reducing Error to 10e-6 for BPSK');
% xlabel('SNR in dB');
% ylabel('Bit Error Rate');
% fprintf('Part B: ');
% toc

%% QAM with BCH 15-7

pp = 1:90

qq= 15*pp

for kk=qq
    
    kk
    
    %clc;clear;close all
    
    % QAM with 4-ary should be able to imporve the bit rate because the number 
    % of bits per symbol is doubled 
    
    % same parameters from part a
    numIterations = 10000;
    numSym = 1000;
    SNR_Vec = 12;
    SNRlen = length(SNR_Vec);
    chan = [1, 0.2, 0.4];
    
    % number of codewords*2 that is used for training
    n = 60;    
    % number of symbols that is used for training aka number of msg bits*2 
    % that is used for training
    numTraining = kk;     
    
    M = 4;
    codeWordLen = 15;
    msgLen = 7;
    
    % 286 codewords transmitted for the given parameters which is 286*7 = 2002 
    % bits aka 1001 symbols
    numWords = ceil(numSym*log2(M)/msgLen);
    
    % number of bits from 'msg' that have to be used for training
    trainingBits = log2(M)*(numTraining/codeWordLen) * msgLen; 
    
    tic;
    % preallocate BER matrix like previously
    BERvec2 = zeros(numIterations, SNRlen);     
    numBits = msgLen*numWords;
    
    % create encoder and decoder objects for the given BCH parameters
    enc = comm.BCHEncoder(codeWordLen, msgLen); 
    dec = comm.BCHDecoder(codeWordLen, msgLen);
    
    parfor ii=1:numIterations
        
        % total bits we can generate is numWords*msgLen = 2002 bits = 1001 symbols
        msg = randi([0, 1], msgLen*numWords, 1);
        
        % encode msg with parity bits inserted after every 7 bits aka every
        % message
        msg_enc = step(enc, msg);
        a = msg_enc;                % checkpoint
        
        % pair up the bits to convert to decimal
        msg_enc = reshape(msg_enc,log2(M),length(msg_enc)/log2(M)).';
        b = msg_enc;                % checkpoint
        
        % convert to decimal
        msg_enc = bi2de(msg_enc);
        
        for jj=1:SNRlen
            % qammod default parameters is gray code ordering and integer inputs 
            tx = qammod(msg_enc, M, 'UnitAveragePower', true);
    
                txChan = filter(chan,1,tx);         % apply the channel
                txNoisy = awgn(txChan,SNR_Vec(jj),'measured'); % add awgn
    
                eq1 = dfe(12,6, lms(0.01));         % create equalizer objecct
                eq1.SigConst = qammod(0:M-1, M, 'UnitAveragePower', true);
                eq1.ResetBeforeFiltering = 1;
                
                txNoisy = equalize(eq1,txNoisy,tx(1:numTraining));  % equalize
            
            rx = qamdemod(txNoisy, M, 'UnitAveragePower', true);    % demodulate
            
            % convert back to binary so that recieved msg can be decoded
            rxTmp = (de2bi(rx)).';
            rxMsg = rxTmp(:);           % columnize
            
            dec_msg = step(dec, rxMsg); % decode
            
            % calculate BER
            [~, BERvec2(ii,jj)] = biterr(msg(trainingBits+1:end), dec_msg(trainingBits+1:end));  
        end
    end
    
    ber2 = mean(BERvec2,1);
    
    %figure;
    %semilogy(SNR_Vec, ber2, 'DisplayName', "BER-4 with ISI")
    %title('Part B')
    %hold on;
    %berTheory2 = berawgn(SNR_Vec,'qam', 4,'nondiff');
    %semilogy(SNR_Vec,berTheory2,'DisplayName', 'Theoretical BER for M=4')
    %legend('Location', 'southwest')
    %fprintf('Part B: ');
    %toc
    
    bit_rate = (numBits - trainingBits)/numBits
    
    % grab last non zero value of BER vector 
    lowest_non_zero_BER = ber2(find(ber2,1,'last'))
    ber2(1)
    
end



##### SOURCE END #####
--></body></html>